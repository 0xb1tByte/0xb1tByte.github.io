---
layout: post
published: true
title: Buffer Overflow Part 1
date: '2024-06-15'
tags:
- Arabic-Article
- System Security
- Exploit Development
---

<div dir="rtl" markdown="1">

السلام عليكم ورحمة الله وبركاته 

هذه المقالة، والمقالات القادمة -بمشيئة الله- سلسلة بسيطة حول ثغرات الـ `Buffer Overflow` 

ليس في ذهني حقيقة عدد مُعيّن لمقالات هذه السلسلة 

لكن أنوي في هذه السلسلة تلخيص وربط أهم الأفكار حول هذا الموضوع من كُتب متفرّقة 

تحديدًا، هذه ستكون قائمة القراءة في هذه السلسلة : 


</div> 

- [Buffer. Overflow. Attacks. DETECT, EXPLOIT, PREVENT](https://a.co/d/fTPXdb6)
- [Computer Security: A Hands-On Approach](https://a.co/d/8n1K5hR)
- [The Shellcoder's Handbook](https://amzn.eu/d/e5ihS4i)


<div dir="rtl" markdown="1">
البدايات كالعادة ستكون تَمهيد، وتركيزنا الأكبر سيكون على الجانب النظري وفهم هذه الثغرة، بعد بناء الأساس اللازم ، سننتقل للجانب العملي 

لنبدأ بسم الله ، 

# ما هو الـ `Buffer` ؟ 
لأن هذه الثغرة مُتعلّقة بالـ `Buffer` ، لنعرف بدايةً ماهو الـ `Buffer` ؟ 

في كتاب [The Shellcoder's Handbook](https://amzn.eu/d/e5ihS4i) نجد التعريف الآتي للـ `Buffer` 

</div>

> A buffer is defined as a limited, contiguously allocated set of memory. The most common buffer in C is an array.



<div dir="rtl" markdown="1">

إذًا ، فالـ `Buffer` مساحة أو حيّز من الذاكرة يستخدمها البرنامج لأغراض تخزين المتغيّرات وأغراض أخرى ، ما يُميّز هذه المساحة ( أو مجموعة العناوين - addresses ) نقطتين : 

**العناوين متتالية** : أي في حال بدأنا التخزين من العنوان X ، عملية التخزين الثانية ستكون في العنوان التالي للعنوان X 

**هذه المساحة محدودة ومعروفة الحجم** : أي أن الـ `Buffer` له سِعة إستيعاب وتخزين محدودة 

أحد أبسط الأمثلة على الـ `Buffer` هو الـ `Array` 

لنأخذ المثال الآتي لاستيعاب مفهوم الـ `Buffer` من زاوية الـ `Array` ( المثال من نفس الكتاب )

</div>


```c
1 #include <stdio.h>
2 #include <string.h>
3 
4 int main () {
5     int array[5] = {1, 2, 3, 4, 5};
6     printf("%d\n", array[5]);
7 }
```

<div dir="rtl" markdown="1">

الكود جدًا بسيط ، قُمنا بتعريف `Array` سِعتها تخزين **خمس** عناصر ، وقمنا بملئ هذه المساحة بالعناصر : `1` , `2` , `3` , `4` , `5`

حتى الآن البرنامج صحيح ، فالـ `Array` التي قمنا بتعريفها تَتّسع لتخزين خمس عناصر 

وفي السطر رقم `6` قمنا بطباعة العنصر رقم `5` في هذه الـ `Array` ، هنا بالطبع يوجد خطأ ، فكما نعرف الـ `index` في الـ `Array` يبدأ من **صفر**

لكن لو قمنا بعمل `Compile` للكود أعلاه ، لن يقوم الـ `Compiler` بطباعة أي خطأ 

![1](https://raw.githubusercontent.com/0xb1tByte/0xb1tbyte.github.io/master/assets/media/BufferOverflow//1.png)


طيب ، ماذا لو قمنا بتنفيذ هذا البرنامج ؟ 

ماذا سيحصل ؟ فنحن هنا نحاول الوصول للعنصر `array[5]` ، وهذا العنصر **خارج نطاق مساحة التخزين** هذه ( الـ `Array` في مثالنا ) ، أي كأننا نحاول الوصول للعنصر **السادس** في الـ `Array` وفي مثالنا الـ `Array` لا تحمل إلّا خمس عناصر 

لو قمنا بتنفيذ البرنامج سنرى الآتي : 

![1](https://raw.githubusercontent.com/0xb1tByte/0xb1tbyte.github.io/master/assets/media/BufferOverflow//2.png)

لاحظ أن البرنامج تم تنفيذه بدون مشاكل كذلك ، وتم طباعة القيمة `134513712`

هذه القيمة هي القيمة المُخزّنة في العنوان الذي حاولنا الوصول له `array[5]`  

لو عدنا لتعريف الـ `Array` سنجد أن آخر العناصر في هذه الـ `Array` يجب أن يكون العنصر `array[4]` ومابعده ليس ضمن هذه الـ `Array`

لكن في مثالنا هذا استطعنا قراءة القيمة في العنوان التالي للعنوان الأخير في الـ `Array` 

وهذا المثال والكود يوضّح كيف يمكننا **الخروج** عن نطاق هذه المساحة والوصول لعناوين أخرى ليست ضمن مساحة الـ `Buffer` أو الـ `Array` في مثالنا هذا

هذه المشكلة بالطبع تحصل في لغة `C` لأن اللغة لا تُجري ما يُعرف بالـ `bounds-checking` على الـ `Buffer`  

أيضًا في المثال السابق رأينا أنه يمكننا **القراءة** خارج نطاق الـ `Buffer` 

في مقالات لاحقة إن شاء الله سنحاول استعراض إجراء عملية **الكتابة** خارج نطاق الـ `Buffer` 

وإلى هنا نكتفي 



</div>

> ℹ️ [ملاحظة]
> هذه المقالة تمّت كتابتها خلال دراسة هذه المواضيع، فكل ما تم ذكره هنا قد يحتمل الخطأ، لكن بالإمكان العودة إلى المراجع التي إستندت عليها هذه المقالة 
